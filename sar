#!/usr/bin/perl

# Copyright (c) 2024 Todd T. Fries <todd@fries.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;
use Digest::SHA1 qw(sha1_hex);
use File::Path qw(make_path);
use File::Spec;
use File::Slurp;
use File::Basename;
use Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);
use Getopt::Std;
use LWP::UserAgent;
use Data::Dumper;
use MIME::Base64;

our $opt_m; # mode
our $opt_v; # verbosity

getopts('m:v');

if (!defined($opt_m)) {
	die "Need '-m <mode>' where <mode> is one of: t (test), x (extract), c (create)";
}
our $v;
if (defined($opt_v)) {
	$v = $opt_v;
} else {
	$v = 0;
}

my $ua = LWP::UserAgent->new();
$ua->agent('Sia-Agent');

# Configuration
my $block_size = 8 * 1024;
my $archive_dir = '/nhome/todd/sarchive';
my $hashes_dir = $archive_dir . "/hashes";

# Create archive dir if it doesn't exist
make_path($archive_dir) unless -d $archive_dir;
make_path($hashes_dir) unless -d $hashes_dir;

my $pass = $ENV{'renterpass'};
our $auth = "Basic " . encode_base64(":$pass","");

if ($opt_m eq "put") {
	my $file = $ARGV[0];
	my $file_content = read_file($file);

	my $res = put('9880',
		'api/worker/objects/name',
		'sarchive',
		$file_content,
		$auth);
	print Dumper($res);
	exit(0);
}

if ($opt_m eq "c") {
	foreach my $path (@ARGV) {
		print "Processing $path\n";
		if (-f $path) {
			my $sha = archive_file($path);
			print $sha . "\n";
			next;
		}
		#if (-d $path) {
		#	process_dir($path);
		#	next;
		#}
	}
	exit(0);
}

if ($opt_m eq "x") {
	foreach my $sha (@ARGV) {
		print "Extracting $sha\n";
		restore_file($sha);
	}
	exit(0);
}

# types of blocks
# dir -> file metadata + pointer
# pointer -> list of blocks
# data -> contents of file


# XXX need to create pointers on the fly vs after all data blocks
#  700mb file took over 15mb of memory

sub archive_file {
    my ($file_path) = @_;
    my $file_size = -s $file_path;
    my $file_name = basename($file_path);
    my @blocks = ();
    
    open(my $in_fh, '<', $file_path) or die "Cannot open $file_path: $!";
    binmode($in_fh);
    
    my $block_count = int($file_size / $block_size);
    $block_count++ if $file_size % $block_size != 0;
    
    for my $block_index (0..$block_count-1) {
        my $block_offset = $block_index * $block_size;
        my $block_size_to_read = ($block_index == $block_count - 1) ? ($file_size % $block_size) : $block_size;
        
        seek($in_fh, $block_offset, SEEK_SET) or die "Cannot seek in $file_path: $!";
        read($in_fh, my $block_data, $block_size_to_read) or die "Cannot read from $file_path: $!";

	my $block_hash = store_block($block_data);        

        push @blocks, $block_hash;
    }
    
    close($in_fh);

    my $sha = make_pointer_blocks(@blocks);

    my $data = "file:$file_path\n";
    $data .= "ptr:$sha\n";

    return store_block(mkheader("dir", $data));
}

# XXX turn this into a bg queue via sqlite db?
sub store_block {
	my ($block_data) = @_;
        my $block_hash = sha1_hex($block_data);
	if (head('9880',
		'api/worker/objects/hashes/'.$block_hash,
		'sarchive',
		$auth)) {
		if ($v>0) {
			print " found $block_hash, not re-uploading\n";
		}
		return $block_hash;
	}
	my $res = put('9880',
		'api/worker/objects/hashes/'.$block_hash,
		'sarchive',
		$block_data,
		$auth);
	if ($v>0) {
		print " put $block_hash\n";
	}
	return $block_hash;
}

sub mkheader {
	my ($type, $data) = @_;
	my $str = "sartype:$type\n";
	$str .= $data;
	return $str;
}

sub make_pointer_blocks {
	my (@blist) = @_;
	my $hdrsize = length(mkheader("ptr",""));
	my $size = $hdrsize;
	my $data = "";
	my $line;
	my @blocks = ();

	print "make_pointer_blocks: $#blist\n";

	foreach my $block (@blist) {
		if (!defined($block)) {
			next;
		}
		if ( (length($block) + $size) > $block_size) {
			push @blocks, store_block(mkheader("ptr",$data));
			$data = "";
			$size = $hdrsize;
		}
		my $str = $block . "\n";
		$data .= $str;
		$size += length($str);
	}
	if (length($data) > 0) {
		push @blocks, store_block(mkheader("ptr", $data));
	}
	if ($#blocks > 0) {
		return make_pointer_blocks(@blocks);
	}
	return $blocks[0];
}

sub restore_file {
    my ($archive_path) = @_;
    my $file_name = basename($archive_path);
    my $restored_file_path = File::Spec->catfile($archive_dir, $file_name . '.restored');
    
    open(my $in_fh, '<', $archive_path) or die "Cannot open $archive_path: $!";
    binmode($in_fh);
    
    open(my $out_fh, '>', $restored_file_path) or die "Cannot create $restored_file_path: $!";
    binmode($out_fh);
    
    while (my $line = <$in_fh>) {
        chomp($line);
        my $block_hash = $line;
        my $block_archive_path = File::Spec->catfile($archive_dir, $block_hash);
        
        open(my $block_in_fh, '<', $block_archive_path) or die "Cannot open $block_archive_path: $!";
	binmode($block_in_fh);
	    my $block_data;
    read($block_in_fh, $block_data, $block_size) or die "Cannot read from $block_archive_path: $!";
    print $out_fh $block_data;
    }

    close($in_fh);
    close($out_fh);

    return $restored_file_path;
}

sub put {
	my ($port, $cmd, $bucket, $data, $auth) = @_;

	my $baseurl = "http://[::1]:${port}/";
	my $url = $baseurl . $cmd . "?bucket=$bucket";
	my $encoded_data;
	my $req;

	my $header = [ 'Content-Type' => 'text/plain',
			'Authorization' => $auth ];

	$req = HTTP::Request->new(PUT => $url,
			$header,
			$data);

	my $res = $ua->request($req);
	return $res;
}

sub head {
	my ($port, $cmd, $bucket, $auth) = @_;

	my $baseurl = "http://[::1]:${port}/";
	my $url = $baseurl . $cmd . "?bucket=$bucket";
	my $encoded_data;
	my $req;

	my $header = [ 'Content-Type' => 'text/plain',
			'Authorization' => $auth ];

	$req = HTTP::Request->new(HEAD => $url,
			$header);

	my $res = $ua->request($req);
	return $res->is_success;
}
